# GrowNet_Contract_v5_master.yaml
# Master, language-agnostic contract for GrowNet public surface and behavioral invariants.

meta:
  version: "v5"
  status: "active"
  replaces: "GrowNet_Contract_v4_master.yaml"
  purpose: >
    Define the cross-language public surface (Python, C++, Java, Mojo) and
    the behavioral invariants for slot selection, frozen slots, two-phase ticking,
    and automatic growth across Slots → Neurons → Layers → Regions.

language_conventions:
  python:
    style: "snake_case, no leading underscores in public API"
  java:
    style: "camelCase"
  cpp:
    style: "method names as in headers; concepts mirror Java/Python"
  mojo:
    style: "struct + fn; all parameters typed; no leading underscores in public API"
  general:
    variable_naming: "use descriptive names; avoid single- or double-character names"

core_invariants:
  - "Learning is local and event-driven; no backpropagation."
  - "Slot selection uses FIRST anchor and binning in both scalar and 2D forms."
  - "Strict capacity: once a neuron reaches its slot_limit, **no new slot is allocated**."
  - "When a new bin is desired but blocked by capacity/out-of-domain, selector marks last_slot_used_fallback = true."
  - "Frozen slots do not update (no reinforcement, no threshold change) while frozen."
  - "Ticks run in two phases: (A) deliver & fire, (B) layer end_tick & bus decay."
  - "Automatic growth escalates strictly: Slots → Neurons → Layers → Regions."
  - "Deterministic wiring: growth reuses recorded mesh rules and tract/windowed wiring."
  - "Buses: inhibition decays multiplicatively; modulation resets to 1.0 each tick; step counter increments by 1 per tick."
  - "Windowed wiring (spatial focus): 'same' padding uses floor(center) with clamping; return value = unique source subscriptions."
  - "Public APIs never throw on normal tick paths; growth is best‑effort and non‑disruptive."

types:
  SlotConfig:
    fields:
      anchor_mode: ["FIRST"]  # anchor at the first observation
      bin_width_pct: float    # scalar bin width in percent
      epsilon_scale: float    # floor for denominator when anchor ~ 0
      # 2D spatial:
      spatial_enabled: bool
      row_bin_width_pct: float
      col_bin_width_pct: float
      # capacity (soft in v4, **strict in v5** via selector behavior)
      slot_limit: int  # -1 = unlimited
      # growth knobs (per‑neuron via its SlotConfig reference)
      growth_enabled: bool
      neuron_growth_enabled: bool
      layer_growth_enabled: bool
      fallback_growth_threshold: int  # consecutive fallback hits before neuron growth request
      neuron_growth_cooldown_ticks: int
      layer_neuron_limit_default: int  # default cap per layer; layer may override
  Weight:
    fields:
      strength: float
      threshold: float
      is_frozen: bool
    methods:
      reinforce(modulation: float): "no‑op if is_frozen"
      update_threshold(effective_input: float): "returns bool fired; no‑op if is_frozen"
      freeze(): "sets is_frozen = true"
      unfreeze(): "sets is_frozen = false"
  Neuron:
    fields:
      id: string
      slots: map  # keyed by int (scalar) or packed rc‑bin int for 2D
      slot_limit: int
      bus: LateralBus
      last_input_value: float
      fired_last: bool
      # temporal focus (scalar):
      focus_anchor: float
      focus_set: bool
      # spatial focus (2D):
      anchor_row: int
      anchor_col: int
      # growth bookkeeping:
      last_slot_used_fallback: bool
      fallback_streak: int
      last_growth_tick: int
      owner: LayerRef  # backref to owning layer
    methods:
      on_input(value: float) -> bool
      on_input_2d(value: float, row: int, col: int) -> bool
      on_output(amplitude: float) -> void
      end_tick() -> void
      connect(target_neuron, feedback: bool=False) -> void
      register_fire_hook(callback(Neuron*, amplitude: float)) -> void
      freeze_last_slot() -> bool
      unfreeze_last_slot() -> bool  # next selection may prefer that slot once
  Layer:
    fields:
      neurons: list<Neuron>
      bus: LateralBus
      neuron_limit: int  # override for this layer; -1 = unlimited
      excitatory_count: int
      inhibitory_count: int
      modulatory_count: int
      region_ref: RegionRef
    methods:
      get_neurons() -> list<Neuron>
      get_bus() -> LateralBus
      forward(value: float) -> void
      forward_2d(frame: list[list[float]]) -> void
      end_tick() -> void
      try_grow_neuron(seed_neuron: Neuron) -> int|None  # returns new index or None/-1 if blocked
      set_neuron_limit(limit: int) -> void
  Tract:
    fields:
      src: Layer
      dst: Layer
      bus: RegionBus|LateralBus
      feedback: bool
      allowed_source_indices: set<int> | null
      sink_map: map<int,int> | null  # when Output2D window centers are used
    methods:
      on_source_fired(source_index: int, amplitude: float) -> void
      attach_source_neuron(new_src_index: int) -> void  # subscribe newly grown source neuron
  Region:
    fields:
      name: string
      layers: list<Layer>
      tracts: list<Tract>
      bus: RegionBus
      input_ports: map<string, list<int>>   # port -> list of layer indices
      output_ports: map<string, list<int>>
      mesh_rules: list<MeshRule>            # recorded connectLayers rules
      rng_seed: int
      growth_policy: GrowthPolicy | null
      enable_spatial_metrics: bool
    methods:
      add_layer(excitatory: int, inhibitory: int, modulatory: int) -> int
      add_input_layer_2d(height: int, width: int, gain: float, epsilon_fire: float) -> int
      add_input_layer_nd(shape: list<int>, gain: float, epsilon_fire: float) -> int
      add_output_layer_2d(height: int, width: int, smoothing: float) -> int
      connect_layers(source_index: int, dest_index: int, probability: float, feedback: bool=False) -> int
      connect_layers_windowed(source_index: int, dest_index: int, kernel_h: int, kernel_w: int,
                              stride_h: int, stride_w: int, padding: "valid"|"same") -> int
      bind_input(port: string, layer_indices: list<int>) -> void
      bind_output(port: string, layer_indices: list<int>) -> void
      tick(port: string, value: float) -> RegionMetrics
      tick_2d(port: string, frame: list[list[float]]) -> RegionMetrics  # tickImage alias
      tick_nd(port: string, flat: list<float>, shape: list<int>) -> RegionMetrics
      autowire_new_neuron(layer: Layer, new_index: int) -> void
      request_layer_growth(saturated_layer: Layer) -> int|None
      set_growth_policy(policy: GrowthPolicy) -> void
      get_growth_policy() -> GrowthPolicy|None
  Buses:
    LateralBus:
      fields: { inhibition_factor: float, modulation_factor: float, current_step: int }
      methods:
        pulse_inhibition(factor: float) -> void
        pulse_modulation(factor: float) -> void
        decay() -> void   # inhibition *= decay_rate; modulation = 1.0; current_step += 1
        get_current_step() -> int
        get_step() -> int # alias
    RegionBus:
      same_as: LateralBus
  MeshRule:
    fields: { src: int, dst: int, prob: float, feedback: bool }
  GrowthPolicy:
    fields:
      enable_layer_growth: bool
      max_layers: int
      avg_slots_threshold: float    # e.g., average slots per neuron threshold to trigger region growth
      percent_neurons_at_capacity_threshold: float  # optional secondary trigger
      layer_cooldown_ticks: int
      rng_seed: int

slot_selection_and_capacity:
  scalar_selector:
    behavior:
      - "Anchor mode FIRST: the first value sets focus_anchor; bin index = floor( |x - anchor| / denom * 100 / bin_width_pct )."
      - "Effective slot_limit = neuron.slot_limit if >= 0 else config.slot_limit."
      - "If desired bin is new but capacity/out-of-domain prevents creation, reuse a deterministic existing slot and set last_slot_used_fallback = true."
      - "At capacity, **do not create** any new slot; reuse an existing one deterministically (implementation-defined but stable)."
      - "Record last selected slot id for freeze convenience."
  spatial_selector_2d:
    behavior:
      - "First spatial input sets (anchor_row, anchor_col)."
      - "Compute (row_bin, col_bin) with row/col bin widths; pack as a deterministic key (implementation may use row_bin * K + col_bin)."
      - "Enforce the same strict capacity and fallback semantics as scalar: no new allocation at capacity; mark fallback when desired key is new/out-of-domain."
      - "Record last selected slot for freeze convenience."

frozen_slots:
  semantics:
    - "Weight.freeze() prevents subsequent reinforce() and update_threshold() effects for that slot."
    - "Neuron.freeze_last_slot() freezes the most recently selected slot if present; returns true if frozen."
    - "Neuron.unfreeze_last_slot() unfreezes that slot and **prefers it once** on the next selection so adaptation resumes on that slot."
    - "Frozen status is slot-local; other slots continue to adapt normally."
  tests_required:
    - "Reinforcement does not change strength while frozen."
    - "Threshold update and fire decision ignore a frozen slot’s learning updates."

two_phase_tick:
  phase_A_deliver_and_fire:
    - "Inputs are delivered once per bound input layer; neurons evaluate on_input/on_input_2d; firing propagates via synapses/tract hooks."
  phase_B_end_tick_and_decay:
    - "Each layer end_tick() runs; then layer.bus.decay(); region bus may decay if present."
    - "Bus.decay(): inhibition *= inhibition_decay; modulation = 1.0; current_step += 1."
    - "Growth checks that rely on current_step (cooldowns) observe the increment at the end of the tick."

growth_escalation:
  order: ["slots", "neurons", "layers", "regions"]
  neuron_growth:
    trigger:
      - "Per-neuron fallback_streak >= fallback_growth_threshold."
      - "Effective slot_limit is active and last_slot_used_fallback was true on recent selections."
      - "Cooldown: (bus.current_step - last_growth_tick) >= neuron_growth_cooldown_ticks."
    action:
      - "Layer.try_grow_neuron(seed_neuron) creates a neuron of the same kind where possible, copies bus/config/limits, sets owner, appends."
      - "Region.autowire_new_neuron(layer, idx) is called to replay mesh rules and attach to relevant tracts."
  layer_growth:
    trigger:
      - "Layer.neuron_limit reached and policy on requesting neuron allows layer_growth_enabled."
    action:
      - "Region.request_layer_growth(saturated_layer) creates a small excitatory-only spillover layer, wires saturated → new with a modest probability (default p≈0.15)."
  region_growth (policy-driven):
    policy:
      enable_layer_growth: "must be true"
      max_layers: "do not exceed"
      avg_slots_threshold: "if average slots per neuron ≥ threshold, region may add a new layer"
      percent_neurons_at_capacity_threshold: "optional additional trigger"
      layer_cooldown_ticks: "cooldown between layer additions"
    wiring_and_determinism:
      - "Use region RNG with seed rng_seed for all cross-boundary growth decisions."
      - "Record MeshRule on connect_layers and reuse for autowiring."
      - "Windowed tracts: use attach_source_neuron(new_src_index) when the growing layer is a tract source."
    safety:
      - "Growth is best-effort; if wiring data are missing, skip silently."
      - "No cross-scope side-effects: region growth does not create slots or neurons directly; it only adds layers."

spatial_focus_windowed_wiring:
  function: connect_layers_windowed
  return_value: "number of unique source subscriptions (distinct source pixels participating in ≥1 window)"
  same_padding_center_rule:
    description: >
      When padding = "same" and kernel sizes are even, define the window center by flooring the midpoint:
      center_row = r0 + kh // 2; center_col = c0 + kw // 2, then clamp to image bounds.
  destination_cases:
    output_layer_2d: "each window connects all source pixels in the window to the center output neuron; duplicate (src,center) edges are deduped"
    generic_destination: "deterministic fan‑out from each participating source pixel to all destination neurons (stopgap until selective 2D context API)"

buses_and_decay:
  inhibition:
    rule: "multiplicative decay each tick"
  modulation:
    rule: "reset to 1.0 each tick"
  step_counter:
    rule: "current_step increments by 1 in decay(); get_current_step()/get_step() must return it"
  configurability:
    inhibition_decay: "0.0..1.0; default ~0.90"
  parity:
    - "C++, Java, Python, Mojo share the same decay semantics and step counter behavior"

metrics:
  RegionMetrics:
    fields:
      delivered_events: int
      total_slots: int
      total_synapses: int
      last_output_bbox: [int, int, int, int] | null
      last_output_centroid: [float, float] | null
      active_pixels: int | null
    notes:
      - "Metrics are best-effort; spatial metrics require enable_spatial_metrics."

public_apis_by_language:
  python:
    SlotConfig:
      factory: "SlotConfig.fixed(delta_percent: float)"
      fields_exposed:
        - anchor_mode
        - bin_width_pct
        - epsilon_scale
        - spatial_enabled
        - row_bin_width_pct
        - col_bin_width_pct
        - slot_limit
        - growth_enabled
        - neuron_growth_enabled
        - layer_growth_enabled
        - fallback_growth_threshold
        - neuron_growth_cooldown_ticks
        - layer_neuron_limit_default
    Weight:
      methods: ["reinforce(modulation: float)", "update_threshold(effective_input: float)->bool", "freeze()", "unfreeze()"]
    Neuron:
      methods:
        - "on_input(value: float)->bool"
        - "on_input_2d(value: float, row: int, col: int)->bool"
        - "connect(target, feedback: bool=False)"
        - "register_fire_hook(callback)"
        - "freeze_last_slot()->bool"
        - "unfreeze_last_slot()->bool"
      fields:
        - slot_limit
        - last_slot_used_fallback
        - fallback_streak
        - last_growth_tick
        - owner
    Layer:
      methods:
        - "get_neurons()->list[Neuron]"
        - "get_bus()->LateralBus"
        - "forward(value: float)"
        - "forward_2d(frame: list[list[float]])"
        - "end_tick()"
        - "try_grow_neuron(seed_neuron: Neuron)->int|None"
        - "set_neuron_limit(limit: int)"
    Region:
      methods:
        - "add_layer(excitatory: int, inhibitory: int, modulatory: int)->int"
        - "add_input_layer_2d(h: int, w: int, gain: float, epsilon_fire: float)->int"
        - "add_input_layer_nd(shape: list[int], gain: float, epsilon_fire: float)->int"
        - "add_output_layer_2d(h: int, w: int, smoothing: float)->int"
        - "connect_layers(src: int, dst: int, probability: float, feedback: bool=False)->int"
        - "connect_layers_windowed(src: int, dst: int, kernel_h: int, kernel_w: int, stride_h: int, stride_w: int, padding: str)->int"
        - "bind_input(port: str, layer_indices: list[int])"
        - "bind_output(port: str, layer_indices: list[int])"
        - "tick(port: str, value: float)->RegionMetrics"
        - "tick_2d(port: str, frame: list[list[float]])->RegionMetrics"
        - "autowire_new_neuron(layer, new_index: int)"
        - "request_layer_growth(layer)->int|None"
        - "set_growth_policy(policy: GrowthPolicy)"
        - "get_growth_policy()->GrowthPolicy|None"
    Tract:
      methods:
        - "attach_source_neuron(new_src_index: int)"
  cpp:
    # Representative signatures (headers govern exact names)
    SlotEngine:
      methods:
        - "Weight& selectOrCreateSlot(Neuron& neuron, double inputValue) const"
        - "Weight& selectOrCreateSlot2D(Neuron& neuron, int row, int col) const"
    Weight:
      methods: ["void freeze()", "void unfreeze()", "void reinforce(double modulation)", "bool updateThreshold(double effectiveInput)"]
    Neuron:
      methods:
        - "bool onInput(double value)"
        - "bool onInput2D(double value, int row, int col)"
        - "void onOutput(double amplitude)"
        - "void endTick()"
        - "void connect(Neuron* target, bool feedback=false)"
        - "bool freezeLastSlot()"
        - "bool unfreezeLastSlot()"
      accessors:
        - "void setOwner(void* layerPtr)"
        - "int getSlotLimit() const"
        - "bool getLastSlotUsedFallback() const"
        - "void setLastSlotUsedFallback(bool v)"
    Layer:
      methods:
        - "int tryGrowNeuron(const Neuron& seed)"   # returns new index or -1
        - "void setNeuronLimit(int limit)"
        - "LateralBus& getBus()"
        - "std::vector<std::shared_ptr<Neuron>>& getNeurons()"
        - "virtual void endTick()"
    Region:
      methods:
        - "int addLayer(int excit, int inhib, int mod)"
        - "Tract& connectLayers(int source, int dest, double probability, bool feedback=false)"
        - "int connectLayersWindowed(int src, int dst, int kh, int kw, int sh, int sw, const std::string& padding, bool feedback=false)"
        - "void autowireNewNeuron(Layer* layer, int newIdx)"
        - "int requestLayerGrowth(Layer* saturated)"
        - "RegionMetrics tick(const std::string& port, double value)"
        - "RegionMetrics tickImage(const std::string& port, const std::vector<std::vector<double>>& frame)"
    Buses:
      methods:
        - "void decay()  # increments currentStep; inhibition *= decay; modulation = 1.0"
        - "long long getCurrentStep() const"
        - "long long getStep() const"
    Tract:
      methods: ["void attach_source_neuron(int new_src_index)"]
  java:
    SlotConfig:
      getters_setters:
        - "double getBinWidthPct()/setBinWidthPct(double)"
        - "int getSlotLimit()/setSlotLimit(int)"
        - "boolean isGrowthEnabled()/setGrowthEnabled(boolean)"
        - "boolean isNeuronGrowthEnabled()/setNeuronGrowthEnabled(boolean)"
        - "int getNeuronGrowthCooldownTicks()/setNeuronGrowthCooldownTicks(int)"
        - "int getFallbackGrowthThreshold()/setFallbackGrowthThreshold(int)"
    SlotEngine:
      methods:
        - "int selectOrCreateSlot(Neuron neuron, double inputValue, SlotConfig cfg)"
        - "SlotConfig getConfig()"
    Neuron:
      fields:
        - "boolean lastSlotUsedFallback"
        - "int fallbackStreak"
        - "long lastGrowthTick"
        - "Layer owner"
      methods:
        - "boolean onInput(double value)"
        - "boolean freezeLastSlot() / boolean unfreezeLastSlot()"
    Layer:
      methods:
        - "int tryGrowNeuron(Neuron seed)"
        - "void setNeuronLimit(int limit)"
        - "void setRegion(Region r)"
    Region:
      methods:
        - "int addLayer(int excitatoryCount, int inhibitoryCount, int modulatoryCount)"
        - "int connectLayers(int sourceIndex, int destIndex, double probability, boolean feedback)"
        - "void autowireNewNeuron(Layer L, int newIdx)"
        - "int requestLayerGrowth(Layer saturated)"
  mojo:
    # Illustrative (shape, not full implementation)
    structs_and_functions:
      - "struct SlotConfig: anchor_mode: String, bin_width_pct: Float64, epsilon_scale: Float64, spatial_enabled: Bool, row_bin_width_pct: Float64, col_bin_width_pct: Float64, slot_limit: Int64, growth_enabled: Bool, neuron_growth_enabled: Bool, layer_growth_enabled: Bool, fallback_growth_threshold: Int64, neuron_growth_cooldown_ticks: Int64, layer_neuron_limit_default: Int64"
      - "struct Weight: strength: Float64, threshold: Float64, is_frozen: Bool"
      - "fn reinforce(weight: inout Weight, modulation: Float64) -> None"
      - "fn update_threshold(weight: inout Weight, effective_input: Float64) -> Bool"
      - "fn freeze(weight: inout Weight) -> None"
      - "fn unfreeze(weight: inout Weight) -> None"
      - "struct Neuron: id: String, slot_limit: Int64, last_slot_used_fallback: Bool, fallback_streak: Int64, last_growth_tick: Int64, owner_id: Int64"
      - "fn on_input(neuron: inout Neuron, value: Float64) -> Bool"
      - "fn on_input_2d(neuron: inout Neuron, value: Float64, row: Int64, col: Int64) -> Bool"
      - "fn freeze_last_slot(neuron: inout Neuron) -> Bool"
      - "fn unfreeze_last_slot(neuron: inout Neuron) -> Bool"
      - "struct LateralBus: inhibition_factor: Float64, modulation_factor: Float64, current_step: Int64"
      - "fn decay(bus: inout LateralBus) -> None  # inhibition *= decay; modulation = 1.0; current_step += 1"
      - "struct GrowthPolicy: enable_layer_growth: Bool, max_layers: Int64, avg_slots_threshold: Float64, percent_neurons_at_capacity_threshold: Float64, layer_cooldown_ticks: Int64, rng_seed: Int64"

error_handling_and_safety:
  - "Selectors and ticks are no-throw under normal conditions (invalid indices raise language-appropriate errors during construction/wiring)."
  - "Growth attempts are best-effort; failures do not abort the tick."
  - "Duplicate connections are deduped in appropriate windowed paths."

diff_from_v4:
  added:
    - "Strict slot capacity: selectors **never** allocate new slots at capacity; fallback is explicit and marked."
    - "Frozen slots with freeze()/unfreeze() and last-slot convenience APIs."
    - "Two-phase tick clarified; bus.current_step increments in decay()."
    - "Neuron growth via fallback_streak and cooldown; Layer.try_grow_neuron and Region.autowire_new_neuron."
    - "Region growth policy/engine hooks (set_growth_policy, request_layer_growth)."
    - "attach_source_neuron on Tract for windowed pipelines."
  clarified:
    - "connect_layers_windowed return semantics (unique source subscriptions) and even-kernel 'center rule'."
    - "Buses: inhibition multiplicative decay; modulation reset; step counter required."
  removed_or_deprecated:
    - "Soft capacity behavior from v4 (selectors allocating at cap) is superseded by strict capacity."

compliance_checklist:
  - "Python public API uses snake_case with no leading underscores."
  - "Mojo uses struct/fn, explicit parameter types, and no leading underscores."
  - "Java and C++ surfaces match the concepts and behavior described here."
  - "Strict capacity and fallback marking present in scalar and 2D selectors."
  - "Frozen slot tests exist and pass."
  - "Growth: neuron growth triggers on fallback_streak with cooldown; layer growth available; region policy honored."
  - "Bus.decay implements step counter increment; cooldown logic uses the step."
  - "Windowed wiring implements center rule; return value = unique source subscriptions."

# ────────────────────────────────────────────────────────────────────────────────
# GrowNet Contract – v5.1 Addendum (append-only; extends v5 without deletions)
# ────────────────────────────────────────────────────────────────────────────────
contract:
  extends_version: 5
  addendum_version: 5.1
  change_type: additive
  note: >
    This section clarifies windowed wiring behavior, enforces the one-growth-per-tick
    invariant at region level, standardizes the unfreeze one-shot flag name, records
    snake_case metric field names, and defines an optional Topographic preset that
    wraps existing windowed wiring. No v5 behavior is removed.

tick:
  clarifications:
    - "RegionBus.current_step MUST increment during bus decay."
    - "A Region MUST grow at most one Layer per tick. If growth occurs in a tick,
       Region.lastLayerGrowthStep MUST equal RegionBus.current_step for that tick."

slots:
  naming:
    prefer_last_slot_once:
      status: normative
      summary: >
        After unfreeze_last_slot(), the flag prefer_last_slot_once causes the neuron to
        prefer the same slot on the next tick exactly once; the flag then clears.

wiring:
  windowed_connect:
    destination_cases:
      output_2d:
        rule: >
          For each sliding window over the 2D source, connect ALL source pixels within the
          (clipped) window to exactly ONE destination neuron: the window's CENTER index
          (center uses floor semantics and is clamped to destination bounds). When a
          (source, center) pair arises from overlapping windows, keep a single edge.
    return_value:
      definition: "The function returns the number of UNIQUE source pixels that participated in ≥ 1 window."
    tracts:
      attach_source_neuron:
        status: required
        summary: >
          When a source-layer neuron grows, Tract.attach_source_neuron(new_source_index)
          MUST re-attach that neuron according to the recorded window geometry so behavior
          remains deterministic.

growth:
  region_growth:
    triggers_or:
      - "avgSlotsThreshold (unchanged from v5)."
      - "percentAtCapFallbackThreshold (unchanged from v5)."
    invariants:
      one_growth_per_tick: MUST
    action:
      spillover_connectivity: "Use p = 1.0 unless a policy explicitly overrides (unchanged from v5)."

metrics:
  region_metrics:
    canonical_fields_snake_case:
      - delivered_events
      - total_slots
      - total_synapses
      - active_pixels      # optional
      - centroid_row       # optional
      - centroid_col       # optional
      - bbox               # optional (row_min, row_max, col_min, col_max)
    note: "CamelCase names may exist historically; new code MUST use snake_case."

presets:
  topographic:
    status: optional_helper   # non-core; wraps windowed_connect
    api:
      name: "connect_layers_topographic(region, src_index, dst_index, cfg) -> int"
      behavior:
        - "First call connect_layers_windowed(...) (center-mapped; dedupe kept)."
        - "Then set each (source→center) synapse weight by distance:"
        - "Gaussian:  w = exp(-d^2 / (2 * sigma_center^2))"
        - "DoG:       w = max(0, exp(-d^2 / (2 * sigma_center^2)) - surround_ratio * exp(-d^2 / (2 * sigma_surround^2)))"
        - "If normalize_incoming is true, scale all incoming weights for each center to sum to 1.0 (epsilon = 1e-12)."
      return_value: "Exactly the return from connect_layers_windowed: unique source count."
    config_defaults:
      kernel_h: 7
      kernel_w: 7
      stride_h: 1
      stride_w: 1
      padding: "same"         # or "valid"
      feedback: false
      weight_mode: "gaussian" # or "dog"
      sigma_center: 2.0
      sigma_surround: 4.0
      surround_ratio: 0.5
      normalize_incoming: true
    determinism: "No RNG; weights are pure functions of geometry."

style:
  identifiers:
    rule: "No single- or double-character identifiers anywhere, including loop indices."
  python_mojo:
    public_naming: "No leading underscores; snake_case for public names."
  mojo:
    constructs: "Use struct and fn with typed parameters."

tests:
  must_pass:
    - "Windowed wiring: unique-source return, center-mapping, dedupe."
    - "Tract growth: attach_source_neuron(new_index) re-attaches deterministically."
    - "Neuron growth: fallback streak + cooldown triggers new neuron; autowiring via mesh rules."
    - "Region growth: OR-trigger works; cooldown enforced; one growth per tick invariant holds."
    - "Topographic preset (if used): Gaussian/DoG weight shape; per-target normalization sums to ~1.0."
