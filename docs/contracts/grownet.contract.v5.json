{
  "meta": {
    "contractVersion": "5",
    "addendumVersion": "5.1",
    "status": "active",
    "replaces": "GrowNet_Contract_v4_master.yaml",
    "purpose": "Define the cross-language public surface (Python, C++, Java, Mojo, TypeScript, Rust) and the behavioral invariants for slot selection, frozen slots, two-phase ticking, and automatic growth across Slots → Neurons → Layers → Regions.",
    "sourceLegacyPath": "docs/GrowNet_Contract_v5_master.yaml",
    "authoritativeFormat": "json",
    "generatedAt": "2025-12-12"
  },
  "languageConventions": {
    "python": {
      "style": "snake_case, no leading underscores in public API"
    },
    "java": {
      "style": "camelCase"
    },
    "cpp": {
      "style": "method names as in headers; concepts mirror Java/Python"
    },
    "mojo": {
      "style": "struct + fn; all parameters typed; no leading underscores in public API"
    },
    "typescript": {
      "style": "camelCase public APIs; PascalCase types"
    },
    "rust": {
      "style": "snake_case functions/fields; PascalCase types; keep public API descriptive"
    },
    "general": {
      "variable_naming": "use descriptive names; avoid single- or double-character names (except i/j loop indices)"
    }
  },
  "coreInvariants": [
    "Learning is local and event-driven; no backpropagation.",
    "Slot selection uses FIRST anchor and binning in both scalar and 2D forms.",
    "Strict capacity: once a neuron reaches its slot_limit, **no new slot is allocated**.",
    "When a new bin is desired but blocked by capacity/out-of-domain, selector marks last_slot_used_fallback = true.",
    "Frozen slots do not update (no reinforcement, no threshold change) while frozen.",
    "Ticks run in two phases: (A) deliver & fire, (B) layer end_tick & bus decay.",
    "Automatic growth escalates strictly: Slots → Neurons → Layers → Regions.",
    "Deterministic wiring: growth reuses recorded mesh rules and tract/windowed wiring.",
    "Buses: inhibition decays multiplicatively; modulation resets to 1.0 each tick; step counter increments by 1 per tick.",
    "Windowed wiring (spatial focus): 'same' padding uses floor(center) with clamping; return value = unique source subscriptions.",
    "Public APIs never throw on normal tick paths; growth is best‑effort and non‑disruptive."
  ],
  "behavior": {
    "slotSelectionAndCapacity": {
      "scalar_selector": {
        "behavior": [
          "Anchor mode FIRST: the first value sets focus_anchor; bin index = floor( |x - anchor| / denom * 100 / bin_width_pct ).",
          "Effective slot_limit = neuron.slot_limit if >= 0 else config.slot_limit.",
          "If desired bin is new but capacity/out-of-domain prevents creation, reuse a deterministic existing slot and set last_slot_used_fallback = true.",
          "At capacity, **do not create** any new slot; reuse an existing one deterministically (implementation-defined but stable).",
          "Record last selected slot id for freeze convenience."
        ]
      },
      "spatial_selector_2d": {
        "behavior": [
          "First spatial input sets (anchor_row, anchor_col).",
          "Compute (row_bin, col_bin) with row/col bin widths; pack as a deterministic key (implementation may use row_bin * K + col_bin).",
          "Enforce the same strict capacity and fallback semantics as scalar: no new allocation at capacity; mark fallback when desired key is new/out-of-domain.",
          "Record last selected slot for freeze convenience."
        ]
      }
    },
    "frozenSlots": {
      "semantics": [
        "Weight.freeze() prevents subsequent reinforce() and update_threshold() effects for that slot.",
        "Neuron.freeze_last_slot() freezes the most recently selected slot if present; returns true if frozen.",
        "Neuron.unfreeze_last_slot() unfreezes that slot and **prefers it once** on the next selection so adaptation resumes on that slot.",
        "Frozen status is slot-local; other slots continue to adapt normally."
      ],
      "tests_required": [
        "Reinforcement does not change strength while frozen.",
        "Threshold update and fire decision ignore a frozen slot’s learning updates."
      ]
    },
    "twoPhaseTick": {
      "phase_A_deliver_and_fire": [
        "Inputs are delivered once per bound input layer; neurons evaluate on_input/on_input_2d; firing propagates via synapses/tract hooks."
      ],
      "phase_B_end_tick_and_decay": [
        "Each layer end_tick() runs; then layer.bus.decay(); region bus may decay if present.",
        "Bus.decay(): inhibition *= inhibition_decay; modulation = 1.0; current_step += 1.",
        "Growth checks that rely on current_step (cooldowns) observe the increment at the end of the tick."
      ]
    },
    "growthEscalation": {
      "order": [
        "slots",
        "neurons",
        "layers",
        "regions"
      ],
      "neuron_growth": {
        "trigger": [
          "Per-neuron fallback_streak >= fallback_growth_threshold.",
          "Effective slot_limit is active and last_slot_used_fallback was true on recent selections.",
          "Cooldown: (bus.current_step - last_growth_tick) >= neuron_growth_cooldown_ticks."
        ],
        "action": [
          "Layer.try_grow_neuron(seed_neuron) creates a neuron of the same kind where possible, copies bus/config/limits, sets owner, appends.",
          "Region.autowire_new_neuron(layer, idx) is called to replay mesh rules and attach to relevant tracts."
        ]
      },
      "layer_growth": {
        "trigger": [
          "Layer.neuron_limit reached and policy on requesting neuron allows layer_growth_enabled."
        ],
        "action": [
          "Region.request_layer_growth(saturated_layer) creates a small excitatory-only spillover layer, wires saturated → new with a modest probability (default p≈0.15)."
        ]
      },
      "region_growth (policy-driven)": {
        "policy": {
          "enable_layer_growth": "must be true",
          "max_layers": "do not exceed",
          "avg_slots_threshold": "if average slots per neuron ≥ threshold, region may add a new layer",
          "percent_neurons_at_capacity_threshold": "optional additional trigger",
          "layer_cooldown_ticks": "cooldown between layer additions"
        },
        "wiring_and_determinism": [
          "Use region RNG with seed rng_seed for all cross-boundary growth decisions.",
          "Record MeshRule on connect_layers and reuse for autowiring.",
          "Windowed tracts: use attach_source_neuron(new_src_index) when the growing layer is a tract source."
        ],
        "safety": [
          "Growth is best-effort; if wiring data are missing, skip silently.",
          "No cross-scope side-effects: region growth does not create slots or neurons directly; it only adds layers."
        ]
      }
    },
    "spatialFocusWindowedWiring": {
      "function": "connect_layers_windowed",
      "return_value": "number of unique source subscriptions (distinct source pixels participating in ≥1 window)",
      "same_padding_center_rule": {
        "description": "When padding = \"same\" and kernel sizes are even, define the window center by flooring the midpoint: center_row = r0 + kh // 2; center_col = c0 + kw // 2, then clamp to image bounds.\n"
      },
      "destination_cases": {
        "output_layer_2d": "each window connects all source pixels in the window to the center output neuron; duplicate (src,center) edges are deduped",
        "generic_destination": "deterministic fan‑out from each participating source pixel to all destination neurons (stopgap until selective 2D context API)"
      }
    },
    "busesAndDecay": {
      "inhibition": {
        "rule": "multiplicative decay each tick"
      },
      "modulation": {
        "rule": "reset to 1.0 each tick"
      },
      "step_counter": {
        "rule": "current_step increments by 1 in decay(); get_current_step()/get_step() must return it"
      },
      "configurability": {
        "inhibition_decay": "0.0..1.0; default ~0.90"
      },
      "parity": [
        "C++, Java, Python, Mojo share the same decay semantics and step counter behavior"
      ]
    },
    "metrics": {
      "RegionMetrics": {
        "fields": {
          "delivered_events": "int",
          "total_slots": "int",
          "total_synapses": "int",
          "last_output_bbox": "[int, int, int, int] | null",
          "last_output_centroid": "[float, float] | null",
          "active_pixels": "int | null"
        },
        "notes": [
          "Metrics are best-effort; spatial metrics require enable_spatial_metrics."
        ]
      }
    }
  },
  "types": {
    "SlotConfig": {
      "fields": {
        "anchor_mode": "[\"FIRST\"]",
        "bin_width_pct": "float",
        "epsilon_scale": "float",
        "spatial_enabled": "bool",
        "row_bin_width_pct": "float",
        "col_bin_width_pct": "float",
        "slot_limit": "int",
        "growth_enabled": "bool",
        "neuron_growth_enabled": "bool",
        "layer_growth_enabled": "bool",
        "fallback_growth_threshold": "int",
        "neuron_growth_cooldown_ticks": "int",
        "layer_neuron_limit_default": "int"
      },
      "methods": []
    },
    "Weight": {
      "fields": {
        "strength": "float",
        "threshold": "float",
        "is_frozen": "bool"
      },
      "methods": [
        {
          "name": "reinforce",
          "params": [
            {
              "name": "modulation",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "reinforce(modulation: float)",
          "notes": "no‑op if is_frozen"
        },
        {
          "name": "update_threshold",
          "params": [
            {
              "name": "effective_input",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "update_threshold(effective_input: float)",
          "notes": "returns bool fired; no‑op if is_frozen"
        },
        {
          "name": "freeze",
          "params": [],
          "returns": "void",
          "signature": "freeze()",
          "notes": "sets is_frozen = true"
        }
      ]
    },
    "Neuron": {
      "fields": {
        "id": "string",
        "slots": "map",
        "slot_limit": "int",
        "bus": "LateralBus",
        "last_input_value": "float",
        "fired_last": "bool",
        "focus_anchor": "float",
        "focus_set": "bool",
        "anchor_row": "int",
        "anchor_col": "int",
        "last_slot_used_fallback": "bool",
        "fallback_streak": "int",
        "last_growth_tick": "int",
        "owner": "LayerRef"
      },
      "methods": [
        {
          "name": "on_input",
          "params": [
            {
              "name": "value",
              "type": "float"
            }
          ],
          "returns": "bool",
          "signature": "on_input(value: float) -> bool"
        },
        {
          "name": "on_input_2d",
          "params": [
            {
              "name": "value",
              "type": "float"
            },
            {
              "name": "row",
              "type": "int"
            },
            {
              "name": "col",
              "type": "int"
            }
          ],
          "returns": "bool",
          "signature": "on_input_2d(value: float, row: int, col: int) -> bool"
        },
        {
          "name": "on_output",
          "params": [
            {
              "name": "amplitude",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "on_output(amplitude: float) -> void"
        },
        {
          "name": "end_tick",
          "params": [],
          "returns": "void",
          "signature": "end_tick() -> void"
        },
        {
          "name": "connect",
          "params": [
            {
              "name": "target_neuron",
              "type": "unknown"
            },
            {
              "name": "feedback",
              "type": "bool",
              "default": "False"
            }
          ],
          "returns": "void",
          "signature": "connect(target_neuron, feedback: bool=False) -> void"
        },
        {
          "name": "register_fire_hook",
          "params": [
            {
              "name": "callback(Neuron*",
              "type": "unknown"
            },
            {
              "name": "amplitude",
              "type": "float)"
            }
          ],
          "returns": "void",
          "signature": "register_fire_hook(callback(Neuron*, amplitude: float)) -> void"
        },
        {
          "name": "freeze_last_slot",
          "params": [],
          "returns": "bool",
          "signature": "freeze_last_slot() -> bool"
        }
      ]
    },
    "Layer": {
      "fields": {
        "neurons": "list<Neuron>",
        "bus": "LateralBus",
        "neuron_limit": "int",
        "excitatory_count": "int",
        "inhibitory_count": "int",
        "modulatory_count": "int",
        "region_ref": "RegionRef"
      },
      "methods": [
        {
          "name": "get_neurons",
          "params": [],
          "returns": "list<Neuron>",
          "signature": "get_neurons() -> list<Neuron>"
        },
        {
          "name": "get_bus",
          "params": [],
          "returns": "LateralBus",
          "signature": "get_bus() -> LateralBus"
        },
        {
          "name": "forward",
          "params": [
            {
              "name": "value",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "forward(value: float) -> void"
        },
        {
          "name": "forward_2d",
          "params": [
            {
              "name": "frame",
              "type": "list[list[float]]"
            }
          ],
          "returns": "void",
          "signature": "forward_2d(frame: list[list[float]]) -> void"
        },
        {
          "name": "end_tick",
          "params": [],
          "returns": "void",
          "signature": "end_tick() -> void"
        },
        {
          "name": "try_grow_neuron",
          "params": [
            {
              "name": "seed_neuron",
              "type": "Neuron"
            }
          ],
          "returns": "int|None",
          "signature": "try_grow_neuron(seed_neuron: Neuron) -> int|None"
        }
      ]
    },
    "Tract": {
      "fields": {
        "src": "Layer",
        "dst": "Layer",
        "bus": "RegionBus|LateralBus",
        "feedback": "bool",
        "allowed_source_indices": "set<int> | null",
        "sink_map": "map<int,int> | null"
      },
      "methods": [
        {
          "name": "on_source_fired",
          "params": [
            {
              "name": "source_index",
              "type": "int"
            },
            {
              "name": "amplitude",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "on_source_fired(source_index: int, amplitude: float) -> void"
        }
      ]
    },
    "Region": {
      "fields": {
        "name": "string",
        "layers": "list<Layer>",
        "tracts": "list<Tract>",
        "bus": "RegionBus",
        "input_ports": "map<string, list<int>>",
        "output_ports": "map<string, list<int>>",
        "mesh_rules": "list<MeshRule>",
        "rng_seed": "int",
        "growth_policy": "GrowthPolicy | null",
        "enable_spatial_metrics": "bool"
      },
      "methods": [
        {
          "name": "add_layer",
          "params": [
            {
              "name": "excitatory",
              "type": "int"
            },
            {
              "name": "inhibitory",
              "type": "int"
            },
            {
              "name": "modulatory",
              "type": "int"
            }
          ],
          "returns": "int",
          "signature": "add_layer(excitatory: int, inhibitory: int, modulatory: int) -> int"
        },
        {
          "name": "add_input_layer_2d",
          "params": [
            {
              "name": "height",
              "type": "int"
            },
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "gain",
              "type": "float"
            },
            {
              "name": "epsilon_fire",
              "type": "float"
            }
          ],
          "returns": "int",
          "signature": "add_input_layer_2d(height: int, width: int, gain: float, epsilon_fire: float) -> int"
        },
        {
          "name": "add_input_layer_nd",
          "params": [
            {
              "name": "shape",
              "type": "list<int>"
            },
            {
              "name": "gain",
              "type": "float"
            },
            {
              "name": "epsilon_fire",
              "type": "float"
            }
          ],
          "returns": "int",
          "signature": "add_input_layer_nd(shape: list<int>, gain: float, epsilon_fire: float) -> int"
        },
        {
          "name": "add_output_layer_2d",
          "params": [
            {
              "name": "height",
              "type": "int"
            },
            {
              "name": "width",
              "type": "int"
            },
            {
              "name": "smoothing",
              "type": "float"
            }
          ],
          "returns": "int",
          "signature": "add_output_layer_2d(height: int, width: int, smoothing: float) -> int"
        },
        {
          "name": "connect_layers",
          "params": [
            {
              "name": "source_index",
              "type": "int"
            },
            {
              "name": "dest_index",
              "type": "int"
            },
            {
              "name": "probability",
              "type": "float"
            },
            {
              "name": "feedback",
              "type": "bool",
              "default": "False"
            }
          ],
          "returns": "int",
          "signature": "connect_layers(source_index: int, dest_index: int, probability: float, feedback: bool=False) -> int"
        },
        {
          "name": "connect_layers_windowed",
          "params": [
            {
              "name": "source_index",
              "type": "int"
            },
            {
              "name": "dest_index",
              "type": "int"
            },
            {
              "name": "kernel_h",
              "type": "int"
            },
            {
              "name": "kernel_w",
              "type": "int"
            },
            {
              "name": "stride_h",
              "type": "int"
            },
            {
              "name": "stride_w",
              "type": "int"
            },
            {
              "name": "padding",
              "type": "\"valid\"|\"same\""
            }
          ],
          "returns": "int",
          "signature": "connect_layers_windowed(source_index: int, dest_index: int, kernel_h: int, kernel_w: int, stride_h: int, stride_w: int, padding: \"valid\"|\"same\") -> int"
        },
        {
          "name": "bind_input",
          "params": [
            {
              "name": "port",
              "type": "string"
            },
            {
              "name": "layer_indices",
              "type": "list<int>"
            }
          ],
          "returns": "void",
          "signature": "bind_input(port: string, layer_indices: list<int>) -> void"
        },
        {
          "name": "bind_output",
          "params": [
            {
              "name": "port",
              "type": "string"
            },
            {
              "name": "layer_indices",
              "type": "list<int>"
            }
          ],
          "returns": "void",
          "signature": "bind_output(port: string, layer_indices: list<int>) -> void"
        },
        {
          "name": "ensure_input_edge",
          "params": [
            {
              "name": "port",
              "type": "string"
            }
          ],
          "returns": "int",
          "signature": "ensure_input_edge(port: string) -> int"
        },
        {
          "name": "ensure_output_edge",
          "params": [
            {
              "name": "port",
              "type": "string"
            }
          ],
          "returns": "int",
          "signature": "ensure_output_edge(port: string) -> int"
        },
        {
          "name": "tick",
          "params": [
            {
              "name": "port",
              "type": "string"
            },
            {
              "name": "value",
              "type": "float"
            }
          ],
          "returns": "RegionMetrics",
          "signature": "tick(port: string, value: float) -> RegionMetrics"
        },
        {
          "name": "tick_2d",
          "params": [
            {
              "name": "port",
              "type": "string"
            },
            {
              "name": "frame",
              "type": "list[list[float]]"
            }
          ],
          "returns": "RegionMetrics",
          "signature": "tick_2d(port: string, frame: list[list[float]]) -> RegionMetrics"
        },
        {
          "name": "tick_nd",
          "params": [
            {
              "name": "port",
              "type": "string"
            },
            {
              "name": "flat",
              "type": "list<float>"
            },
            {
              "name": "shape",
              "type": "list<int>"
            }
          ],
          "returns": "RegionMetrics",
          "signature": "tick_nd(port: string, flat: list<float>, shape: list<int>) -> RegionMetrics"
        },
        {
          "name": "autowire_new_neuron",
          "params": [
            {
              "name": "layer",
              "type": "Layer"
            },
            {
              "name": "new_index",
              "type": "int"
            }
          ],
          "returns": "void",
          "signature": "autowire_new_neuron(layer: Layer, new_index: int) -> void"
        },
        {
          "name": "request_layer_growth",
          "params": [
            {
              "name": "saturated_layer",
              "type": "Layer"
            }
          ],
          "returns": "int|None",
          "signature": "request_layer_growth(saturated_layer: Layer) -> int|None"
        },
        {
          "name": "set_growth_policy",
          "params": [
            {
              "name": "policy",
              "type": "GrowthPolicy"
            }
          ],
          "returns": "void",
          "signature": "set_growth_policy(policy: GrowthPolicy) -> void"
        },
        {
          "name": "get_growth_policy",
          "params": [],
          "returns": "GrowthPolicy|None",
          "signature": "get_growth_policy() -> GrowthPolicy|None"
        },
        {
          "name": "pulse_inhibition",
          "params": [
            {
              "name": "factor",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "pulse_inhibition(factor: float) -> void"
        },
        {
          "name": "pulse_modulation",
          "params": [
            {
              "name": "factor",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "pulse_modulation(factor: float) -> void"
        },
        {
          "name": "compute_spatial_metrics",
          "params": [
            {
              "name": "image_2d",
              "type": "list[list[float]]"
            },
            {
              "name": "prefer_output",
              "type": "bool",
              "default": "True"
            }
          ],
          "returns": "RegionMetrics",
          "signature": "compute_spatial_metrics(image_2d: list[list[float]], prefer_output: bool=True) -> RegionMetrics"
        },
        {
          "name": "prune",
          "params": [
            {
              "name": "synapse_stale_window",
              "type": "int"
            },
            {
              "name": "synapse_min_strength",
              "type": "float"
            }
          ],
          "returns": "PruneSummary",
          "signature": "prune(synapse_stale_window: int, synapse_min_strength: float) -> PruneSummary"
        }
      ]
    },
    "LateralBus": {
      "fields": {
        "inhibition_factor": "float",
        "modulation_factor": "float",
        "current_step": "int"
      },
      "methods": [
        {
          "name": "pulse_inhibition",
          "params": [
            {
              "name": "factor",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "pulse_inhibition(factor: float) -> void"
        },
        {
          "name": "pulse_modulation",
          "params": [
            {
              "name": "factor",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "pulse_modulation(factor: float) -> void"
        },
        {
          "name": "decay",
          "params": [],
          "returns": "void",
          "signature": "decay() -> void"
        },
        {
          "name": "get_current_step",
          "params": [],
          "returns": "int",
          "signature": "get_current_step() -> int"
        },
        {
          "name": "get_step",
          "params": [],
          "returns": "int",
          "signature": "get_step() -> int"
        },
        {
          "name": "get_inhibition_factor",
          "params": [],
          "returns": "float",
          "signature": "get_inhibition_factor() -> float"
        },
        {
          "name": "set_inhibition_factor",
          "params": [
            {
              "name": "factor",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "set_inhibition_factor(factor: float) -> void"
        },
        {
          "name": "get_modulation_factor",
          "params": [],
          "returns": "float",
          "signature": "get_modulation_factor() -> float"
        },
        {
          "name": "set_modulation_factor",
          "params": [
            {
              "name": "factor",
              "type": "float"
            }
          ],
          "returns": "void",
          "signature": "set_modulation_factor(factor: float) -> void"
        },
        {
          "name": "get_inhibition_decay",
          "params": [],
          "returns": "float",
          "signature": "get_inhibition_decay() -> float"
        }
      ],
      "group": "Buses"
    },
    "RegionBus": {
      "fields": {},
      "methods": [],
      "group": "Buses",
      "sameAs": "LateralBus"
    },
    "MeshRule": {
      "fields": {
        "src": "int",
        "dst": "int",
        "prob": "float",
        "feedback": "bool"
      },
      "methods": []
    },
    "GrowthPolicy": {
      "fields": {
        "enable_layer_growth": "bool",
        "max_layers": "int",
        "avg_slots_threshold": "float",
        "percent_neurons_at_capacity_threshold": "float",
        "layer_cooldown_ticks": "int",
        "rng_seed": "int"
      },
      "methods": []
    },
    "RegionMetrics": {
      "fields": {
        "delivered_events": "int",
        "total_slots": "int",
        "total_synapses": "int",
        "last_output_bbox": "[int, int, int, int] | null",
        "last_output_centroid": "[float, float] | null",
        "active_pixels": "int | null"
      },
      "methods": [],
      "notes": [
        "Metrics are best-effort; spatial metrics require enable_spatial_metrics."
      ]
    }
  },
  "publicApisByLanguage": {
    "python": {
      "SlotConfig": {
        "factory": "SlotConfig.fixed(delta_percent: float)",
        "fields_exposed": [
          "anchor_mode",
          "bin_width_pct",
          "epsilon_scale",
          "spatial_enabled",
          "row_bin_width_pct",
          "col_bin_width_pct",
          "slot_limit",
          "growth_enabled",
          "neuron_growth_enabled",
          "layer_growth_enabled",
          "fallback_growth_threshold",
          "neuron_growth_cooldown_ticks",
          "layer_neuron_limit_default"
        ]
      },
      "Weight": {
        "methods": [
          "reinforce(modulation: float)",
          "update_threshold(effective_input: float)->bool",
          "freeze()",
          "unfreeze()"
        ]
      },
      "Neuron": {
        "methods": [
          "on_input(value: float)->bool",
          "on_input_2d(value: float, row: int, col: int)->bool",
          "connect(target, feedback: bool=False)",
          "register_fire_hook(callback)",
          "freeze_last_slot()->bool",
          "unfreeze_last_slot()->bool"
        ],
        "fields": [
          "slot_limit",
          "last_slot_used_fallback",
          "fallback_streak",
          "last_growth_tick",
          "owner"
        ]
      },
      "Layer": {
        "methods": [
          "get_neurons()->list[Neuron]",
          "get_bus()->LateralBus",
          "forward(value: float)",
          "forward_2d(frame: list[list[float]])",
          "end_tick()",
          "try_grow_neuron(seed_neuron: Neuron)->int|None",
          "set_neuron_limit(limit: int)"
        ]
      },
      "Region": {
        "methods": [
          "add_layer(excitatory: int, inhibitory: int, modulatory: int)->int",
          "add_input_layer_2d(h: int, w: int, gain: float, epsilon_fire: float)->int",
          "add_input_layer_nd(shape: list[int], gain: float, epsilon_fire: float)->int",
          "add_output_layer_2d(h: int, w: int, smoothing: float)->int",
          "connect_layers(src: int, dst: int, probability: float, feedback: bool=False)->int",
          "connect_layers_windowed(src: int, dst: int, kernel_h: int, kernel_w: int, stride_h: int, stride_w: int, padding: str)->int",
          "bind_input(port: str, layer_indices: list[int])",
          "bind_output(port: str, layer_indices: list[int])",
          "tick(port: str, value: float)->RegionMetrics",
          "tick_2d(port: str, frame: list[list[float]])->RegionMetrics",
          "autowire_new_neuron(layer, new_index: int)",
          "request_layer_growth(layer)->int|None",
          "set_growth_policy(policy: GrowthPolicy)",
          "get_growth_policy()->GrowthPolicy|None"
        ]
      },
      "Tract": {
        "methods": [
          "attach_source_neuron(new_src_index: int)"
        ]
      }
    },
    "cpp": {
      "SlotEngine": {
        "methods": [
          "Weight& selectOrCreateSlot(Neuron& neuron, double inputValue) const",
          "Weight& selectOrCreateSlot2D(Neuron& neuron, int row, int col) const"
        ]
      },
      "Weight": {
        "methods": [
          "void freeze()",
          "void unfreeze()",
          "void reinforce(double modulation)",
          "bool updateThreshold(double effectiveInput)"
        ]
      },
      "Neuron": {
        "methods": [
          "bool onInput(double value)",
          "bool onInput2D(double value, int row, int col)",
          "void onOutput(double amplitude)",
          "void endTick()",
          "void connect(Neuron* target, bool feedback=false)",
          "bool freezeLastSlot()",
          "bool unfreezeLastSlot()"
        ],
        "accessors": [
          "void setOwner(void* layerPtr)",
          "int getSlotLimit() const",
          "bool getLastSlotUsedFallback() const",
          "void setLastSlotUsedFallback(bool v)"
        ]
      },
      "Layer": {
        "methods": [
          "int tryGrowNeuron(const Neuron& seed)",
          "void setNeuronLimit(int limit)",
          "LateralBus& getBus()",
          "std::vector<std::shared_ptr<Neuron>>& getNeurons()",
          "virtual void endTick()"
        ]
      },
      "Region": {
        "methods": [
          "int addLayer(int excit, int inhib, int mod)",
          "Tract& connectLayers(int source, int dest, double probability, bool feedback=false)",
          "int connectLayersWindowed(int src, int dst, int kh, int kw, int sh, int sw, const std::string& padding, bool feedback=false)",
          "void autowireNewNeuron(Layer* layer, int newIdx)",
          "int requestLayerGrowth(Layer* saturated)",
          "RegionMetrics tick(const std::string& port, double value)",
          "RegionMetrics tickImage(const std::string& port, const std::vector<std::vector<double>>& frame)"
        ]
      },
      "Buses": {
        "methods": [
          "void decay()  # increments currentStep; inhibition *= decay; modulation = 1.0",
          "long long getCurrentStep() const",
          "long long getStep() const"
        ]
      },
      "Tract": {
        "methods": [
          "void attach_source_neuron(int new_src_index)"
        ]
      }
    },
    "java": {
      "SlotConfig": {
        "getters_setters": [
          "double getBinWidthPct()/setBinWidthPct(double)",
          "int getSlotLimit()/setSlotLimit(int)",
          "boolean isGrowthEnabled()/setGrowthEnabled(boolean)",
          "boolean isNeuronGrowthEnabled()/setNeuronGrowthEnabled(boolean)",
          "int getNeuronGrowthCooldownTicks()/setNeuronGrowthCooldownTicks(int)",
          "int getFallbackGrowthThreshold()/setFallbackGrowthThreshold(int)"
        ]
      },
      "SlotEngine": {
        "methods": [
          "int selectOrCreateSlot(Neuron neuron, double inputValue, SlotConfig cfg)",
          "SlotConfig getConfig()"
        ]
      },
      "Neuron": {
        "fields": [
          "boolean lastSlotUsedFallback",
          "int fallbackStreak",
          "long lastGrowthTick",
          "Layer owner"
        ],
        "methods": [
          "boolean onInput(double value)",
          "boolean freezeLastSlot() / boolean unfreezeLastSlot()"
        ]
      },
      "Layer": {
        "methods": [
          "int tryGrowNeuron(Neuron seed)",
          "void setNeuronLimit(int limit)",
          "void setRegion(Region r)"
        ]
      },
      "Region": {
        "methods": [
          "int addLayer(int excitatoryCount, int inhibitoryCount, int modulatoryCount)",
          "int connectLayers(int sourceIndex, int destIndex, double probability, boolean feedback)",
          "void autowireNewNeuron(Layer L, int newIdx)",
          "int requestLayerGrowth(Layer saturated)"
        ]
      }
    },
    "mojo": {
      "structs_and_functions": [
        "struct SlotConfig: anchor_mode: String, bin_width_pct: Float64, epsilon_scale: Float64, spatial_enabled: Bool, row_bin_width_pct: Float64, col_bin_width_pct: Float64, slot_limit: Int64, growth_enabled: Bool, neuron_growth_enabled: Bool, layer_growth_enabled: Bool, fallback_growth_threshold: Int64, neuron_growth_cooldown_ticks: Int64, layer_neuron_limit_default: Int64",
        "struct Weight: strength: Float64, threshold: Float64, is_frozen: Bool",
        "fn reinforce(weight: inout Weight, modulation: Float64) -> None",
        "fn update_threshold(weight: inout Weight, effective_input: Float64) -> Bool",
        "fn freeze(weight: inout Weight) -> None",
        "fn unfreeze(weight: inout Weight) -> None",
        "struct Neuron: id: String, slot_limit: Int64, last_slot_used_fallback: Bool, fallback_streak: Int64, last_growth_tick: Int64, owner_id: Int64",
        "fn on_input(neuron: inout Neuron, value: Float64) -> Bool",
        "fn on_input_2d(neuron: inout Neuron, value: Float64, row: Int64, col: Int64) -> Bool",
        "fn freeze_last_slot(neuron: inout Neuron) -> Bool",
        "fn unfreeze_last_slot(neuron: inout Neuron) -> Bool",
        "struct LateralBus: inhibition_factor: Float64, modulation_factor: Float64, current_step: Int64",
        "fn decay(bus: inout LateralBus) -> None  # inhibition *= decay; modulation = 1.0; current_step += 1",
        "struct GrowthPolicy: enable_layer_growth: Bool, max_layers: Int64, avg_slots_threshold: Float64, percent_neurons_at_capacity_threshold: Float64, layer_cooldown_ticks: Int64, rng_seed: Int64"
      ]
    }
  },
  "errorHandlingAndSafety": [
    "Selectors and ticks are no-throw under normal conditions (invalid indices raise language-appropriate errors during construction/wiring).",
    "Growth attempts are best-effort; failures do not abort the tick.",
    "Duplicate connections are deduped in appropriate windowed paths."
  ],
  "diffFromV4": {
    "added": [
      "Strict slot capacity: selectors **never** allocate new slots at capacity; fallback is explicit and marked.",
      "Frozen slots with freeze()/unfreeze() and last-slot convenience APIs.",
      "Two-phase tick clarified; bus.current_step increments in decay().",
      "Neuron growth via fallback_streak and cooldown; Layer.try_grow_neuron and Region.autowire_new_neuron.",
      "Region growth policy/engine hooks (set_growth_policy, request_layer_growth).",
      "attach_source_neuron on Tract for windowed pipelines."
    ],
    "clarified": [
      "connect_layers_windowed return semantics (unique source subscriptions) and even-kernel 'center rule'.",
      "Buses: inhibition multiplicative decay; modulation reset; step counter required."
    ],
    "removed_or_deprecated": [
      "Soft capacity behavior from v4 (selectors allocating at cap) is superseded by strict capacity."
    ]
  },
  "complianceChecklist": [
    "Python public API uses snake_case with no leading underscores.",
    "Mojo uses struct/fn, explicit parameter types, and no leading underscores.",
    "Java and C++ surfaces match the concepts and behavior described here.",
    "Strict capacity and fallback marking present in scalar and 2D selectors.",
    "Frozen slot tests exist and pass.",
    "Growth: neuron growth triggers on fallback_streak with cooldown; layer growth available; region policy honored.",
    "Bus.decay implements step counter increment; cooldown logic uses the step.",
    "Windowed wiring implements center rule; return value = unique source subscriptions."
  ],
  "addendum": {
    "contract": {
      "extends_version": 5,
      "addendum_version": 5.1,
      "change_type": "additive",
      "note": "This section clarifies windowed wiring behavior, enforces the one-growth-per-tick invariant at region level, standardizes the unfreeze one-shot flag name, records snake_case metric field names, and defines an optional Topographic preset that wraps existing windowed wiring. No v5 behavior is removed.\n"
    },
    "tick": {
      "clarifications": [
        "RegionBus.current_step MUST increment during bus decay.",
        "A Region MUST grow at most one Layer per tick. If growth occurs in a tick, Region.lastLayerGrowthStep MUST equal RegionBus.current_step for that tick."
      ]
    },
    "slots": {
      "naming": {
        "prefer_last_slot_once": {
          "status": "normative",
          "summary": "After unfreeze_last_slot(), the flag prefer_last_slot_once causes the neuron to prefer the same slot on the next tick exactly once; the flag then clears.\n"
        }
      }
    },
    "wiring": {
      "windowed_connect": {
        "destination_cases": {
          "output_2d": {
            "rule": "For each sliding window over the 2D source, connect ALL source pixels within the (clipped) window to exactly ONE destination neuron: the window's CENTER index (center uses floor semantics and is clamped to destination bounds). When a (source, center) pair arises from overlapping windows, keep a single edge.\n"
          }
        },
        "return_value": {
          "definition": "The function returns the number of UNIQUE source pixels that participated in ≥ 1 window."
        },
        "tracts": {
          "attach_source_neuron": {
            "status": "required",
            "summary": "When a source-layer neuron grows, Tract.attach_source_neuron(new_source_index) MUST re-attach that neuron according to the recorded window geometry so behavior remains deterministic.\n"
          }
        }
      }
    },
    "growth": {
      "region_growth": {
        "triggers_or": [
          "avgSlotsThreshold (unchanged from v5).",
          "percentAtCapFallbackThreshold (unchanged from v5)."
        ],
        "invariants": {
          "one_growth_per_tick": "MUST"
        },
        "action": {
          "spillover_connectivity": "Use p = 1.0 unless a policy explicitly overrides (unchanged from v5)."
        }
      }
    },
    "metrics": {
      "region_metrics": {
        "canonical_fields_snake_case": [
          "delivered_events",
          "total_slots",
          "total_synapses",
          "active_pixels",
          "centroid_row",
          "centroid_col",
          "bbox"
        ],
        "note": "CamelCase names may exist historically; new code MUST use snake_case."
      }
    },
    "presets": {
      "topographic": {
        "status": "optional_helper",
        "api": {
          "name": "connect_layers_topographic(region, src_index, dst_index, cfg) -> int",
          "behavior": [
            "First call connect_layers_windowed(...) (center-mapped; dedupe kept).",
            "Then set each (source→center) synapse weight by distance:",
            "Gaussian:  w = exp(-d^2 / (2 * sigma_center^2))",
            "DoG:       w = max(0, exp(-d^2 / (2 * sigma_center^2)) - surround_ratio * exp(-d^2 / (2 * sigma_surround^2)))",
            "If normalize_incoming is true, scale all incoming weights for each center to sum to 1.0 (epsilon = 1e-12)."
          ],
          "return_value": "Exactly the return from connect_layers_windowed: unique source count."
        },
        "config_defaults": {
          "kernel_h": 7,
          "kernel_w": 7,
          "stride_h": 1,
          "stride_w": 1,
          "padding": "same",
          "feedback": false,
          "weight_mode": "gaussian",
          "sigma_center": 2.0,
          "sigma_surround": 4.0,
          "surround_ratio": 0.5,
          "normalize_incoming": true
        },
        "determinism": "No RNG; weights are pure functions of geometry."
      }
    },
    "style": {
      "identifiers": {
        "rule": "No single- or double-character identifiers anywhere, including loop indices."
      },
      "python_mojo": {
        "public_naming": "No leading underscores; snake_case for public names."
      },
      "mojo": {
        "constructs": "Use struct and fn with typed parameters."
      }
    },
    "tests": {
      "must_pass": [
        "Windowed wiring: unique-source return, center-mapping, dedupe.",
        "Tract growth: attach_source_neuron(new_index) re-attaches deterministically.",
        "Neuron growth: fallback streak + cooldown triggers new neuron; autowiring via mesh rules.",
        "Region growth: OR-trigger works; cooldown enforced; one growth per tick invariant holds.",
        "Topographic preset (if used): Gaussian/DoG weight shape; per-target normalization sums to ~1.0."
      ]
    }
  },
  "evaluation": {
    "knowledgeUnits": {
      "ku": {
        "name": "KU",
        "meaning": "Knowledge Units",
        "definition": "Per-sample measure of correct, generalizable structure acquired beyond literal memorization of the sample.",
        "baseline": "KU ≈ 1.0 means the model learned only the literal sample (no reliable correct implications)."
      },
      "bku": {
        "name": "BKU",
        "meaning": "Bad Knowledge Units",
        "definition": "Per-sample measure of incorrect or harmful generalizations induced by the sample, including hallucinated facts and biased stereotypes.",
        "baseline": "BKU = 0.0 means the model did not induce hallucinations/bias from the sample under the evaluation halo."
      },
      "derived": {
        "knowledgePrecision": "KU / (KU + BKU + epsilon)",
        "netKUOptional": "KU - lambda * BKU (lambda >= 1)"
      },
      "canonicalDocRefs": [
        "docs/KnowledgeUnits.md",
        "docs/KU_BKU_Evaluation_Protocol.md"
      ],
      "notes": [
        "KU/BKU are evaluation-level metrics; they are not required to be part of RegionMetrics public API."
      ]
    }
  }
}