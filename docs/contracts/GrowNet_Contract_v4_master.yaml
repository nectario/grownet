
meta:
  name: "GrowNet Contract"
  version: "4.0.0"
  status: "draft"
  date: "2025-08-30"
  normative_language: "java"
  languages: ["java", "python", "cpp", "mojo"]
  summary: >
    Normative cross-language interface + behavior for Region/Layer/Neuron/Slot/Synapse/Weight,
    Temporal Focus (anchor-based), Growth hooks, and port binding. Java is the gold reference;
    other languages must mirror semantics and public surface. No legacy paths required.

conventions:
  naming:
    java:
      classes: PascalCase
      methods: camelCase
      fields: camelCase (public allowed where used in repo)
    python:
      modules: snake_case
      classes: PascalCase
      methods: snake_case
      fields: snake_case (no leading '_' for public API fields)
    mojo:
      types: "struct"
      fns: "fn"
      params: explicitly typed
      notes: "Avoid clever metaprogramming; keep parity with Python/Java"
    cpp:
      headers_define_shape: true
      namespaces: ["grownet"]
      ownership: "use std::unique_ptr/shared_ptr consistently"
  general:
    - "Ports are edges; bindings create edge layers per port."
    - "tick2D is the generic 2D entry; tickImage delegates to tick2D."
    - "Future: tickND reserved; ND InputEdge binding exists."
    - "Do not remove public methods; if renamed, keep a delegating alias for one minor version."
    - "Region.tick() must not throw; growth hooks are best‑effort."
    - "Randomness: seed local RNGs with deterministic seeds in demos/tests."

enums:
  SlotPolicy: ["FIXED", "NONUNIFORM", "ADAPTIVE"]
  AnchorMode: ["FIRST", "EMA", "WINDOW", "LAST"]

types:
  Weight:
    description: "Edge-compartment weight with threshold/strength/last_step bookkeeping."
    java:
      public_fields: ["strengthValue", "threshold", "lastStep"]
      methods: ["reinforce(double factor)", "updateThreshold(double stimulus): boolean"]
  Synapse:
    description: "Directed connection between two neurons with a Weight."
    java:
      ctor: "Synapse(Neuron src, Neuron dst, boolean feedback)"
      getters: ["getWeight()", "getDst()", "isFeedback()"]
  SlotConfig:
    description: "Policy and knobs for mapping deltas to integer slots (bins)."
    fields:
      - {name: "policy", type: "SlotPolicy", default: "FIXED"}
      - {name: "slotWidthPercent", type: "double", default: 10.0, note: "legacy seed for FIXED/ADAPTIVE"}
      - {name: "nonuniformEdges", type: "List<double>", default: "[]", note: "ascending in % units"}
      - {name: "maxSlots", type: "int", default: -1, note: "-1 = unbounded (legacy)"}
      # v4 — Temporal Focus knobs
      - {name: "anchorMode", type: "AnchorMode", default: "FIRST"}
      - {name: "binWidthPct", type: "double", default: 10.0}
      - {name: "epsilonScale", type: "double", default: 1e-6}
      - {name: "recenterThresholdPct", type: "double", default: 35.0}
      - {name: "recenterLockTicks", type: "int", default: 20}
      - {name: "anchorBeta", type: "double", default: 0.05}
      - {name: "outlierGrowthThresholdPct", type: "double", default: 60.0}
      - {name: "slotLimit", type: "int", default: 16}
    builders:
      java:
        - "static SlotConfig fixed(double widthPercent)"
        - "static SlotConfig nonuniform(List<Double> edgesAsc)"
        - "static SlotConfig adaptive(double seedWidthPercent, int maxSlots)"
      python:
        - "fixed(delta_percent: float) -> SlotConfig"
        - "nonuniform(edges_percent: List[float]) -> SlotConfig"
        - "adaptive() -> SlotConfig"
  SlotEngine:
    description: "Maps input change to integer slot id and ensures capacity/clamp."
    java:
      methods:
        - "int slotId(double lastInput, double newInput, int slotsLen)"
        - "int selectOrCreateSlot(Neuron n, double x, SlotConfig cfg)  # anchor-based"
    python:
      methods:
        - "slot_id(last_input: float, current_input: float, known_slots: int) -> int"
        - "select_or_create_slot(neuron, input_value: float, tick_count: int=0) -> Weight  # anchor-based"
    cpp:
      header:
        - "int slotId(double lastInput, double currentInput, int knownSlots) const;"
        - "Weight& selectOrCreateSlot(Neuron& neuron, double inputValue) const;"
    mojo:
      notes: "Keep identical math to Python; avoid non-portable tricks."
  LateralBus:
    description: "Per-layer/region ephemeral modulation/inhibition factors with decay()."
  RegionBus:
    description: "Region-scope bus. Pulses propagate here and per-layer."
  Neuron:
    description: "Base neuron with slot logic and unified onInput/onOutput contract; subtypes implement fire()."
    fields_common:
      - {name: "neuronId/id", type: "string"}
      - {name: "slot_engine/slotEngine", type: "SlotEngine"}
      - {name: "slot_limit/slotLimit", type: "int", default: -1}
      - {name: "slots", type: "Map<int, Weight>"}
      - {name: "outgoing", type: "List<Synapse>"}
      - {name: "have_last_input", type: "bool"}
      - {name: "last_input_value", type: "double"}
      - {name: "fired_last/last_fired", type: "bool"}
      # v4 focus state
      - {name: "focus_anchor/focusAnchor", type: "double", default: 0.0}
      - {name: "focus_set/focusSet", type: "bool", default: false}
      - {name: "focus_lock_until_tick/focusLockUntilTick", type: "long/int", default: 0}
    api:
      java:
        getters:
          - "Map<Integer, Weight> getSlots()"
          - "List<Synapse> getOutgoing()"
          - "LateralBus getBus()"
          - "String getId()"
          - "double getLastInputValue()"
          - "double getFocusAnchor()"
        methods:
          - "void connect(Neuron target, boolean feedback)"
          - "int pruneSynapses(long staleWindow, double minStrength)"
      python:
        methods:
          - "connect(target: Neuron, feedback: bool=False) -> None"
          - "prune_synapses(stale_window: int, min_strength: float) -> int"
          - "slots() -> Dict[int, Weight]"
          - "get_outgoing() -> List[Synapse]"
  Layer:
    description: "Population with a shared bus."
    java:
      ctor: "Layer(int excitatoryCount, int inhibitoryCount, int modulatoryCount)"
      methods:
        - "List<Neuron> getNeurons()"
        - "LateralBus getBus()"
        - "void endTick()"
        - "(optional) Neuron spawnSiblingLike(Neuron like, double lastInput, double inheritProb)  # optional; GrowthEngine may reflectively invoke"
  InputLayer2D:
    description: "Shape-aware input edge for 2D frames."
    java:
      methods:
        - "void forwardImage(double[][] frame)"
        - "void forward(double value)"
  OutputLayer2D:
    description: "Shape-aware output sink for 2D frames."
    java:
      methods:
        - "double[][] getLastFrame()   # if implemented"
  Region:
    description: "Orchestrates layers, wiring, ticks, pulses, and prune."
    java:
      fields:
        - "List<Layer> layers"
        - "Map<String, Integer> inputEdges  # per-port Input edge layer index"
        - "Map<String, Integer> outputEdges # per-port Output edge layer index"
        - "(optional) growthPolicy: ai.nektron.grownet.growth.GrowthPolicy"
      constructors:
        - "Region(String name)"
      methods:
        - "int addLayer(int excitatoryCount, int inhibitoryCount, int modulatoryCount)"
        - "int addInputLayer2D(int height, int width, double gain, double epsilonFire)"
        - "int addOutputLayer2D(int height, int width, double smoothing)"
        - "int connectLayers(int sourceIndex, int destIndex, double probability, boolean feedback)"
        - "int connectLayers(int sourceIndex, int destIndex, double probability)"
        - "void bindInput(String port, List<Integer> layerIndices)  # scalar"
        - "void bindOutput(String port, List<Integer> layerIndices) # scalar"
        - "void bindInput2D(String port, int height, int width, double gain, double epsilonFire, List<Integer> layerIndices)"
        - "void bindInputND(String port, int[] shape, double gain, double epsilonFire, List<Integer> layerIndices)  # reserved; present in code"
        - "RegionMetrics tick(String port, double value)"
        - "RegionMetrics tick2D(String port, double[][] frame)"
        - "RegionMetrics tickImage(String port, double[][] frame)  # delegates to tick2D"
        - "void pulseInhibition(double factor)"
        - "void pulseModulation(double factor)"
        - "PruneSummary prune(long synapseStaleWindow, double synapseMinStrength)"
        - "String getName()"
        - "List<Layer> getLayers()"
        - "RegionBus getBus()"
        - "(optional) GrowthPolicy getGrowthPolicy(), Region setGrowthPolicy(GrowthPolicy gp)"
  RegionMetrics:
    description: "Lightweight counters for a Region tick."
    java:
      fields: ["deliveredEvents", "slotsCount", "synapsesCount"]
      methods: ["incDeliveredEvents()", "addSlots(int n)", "addSynapses(int n)"]

temporal_focus_v4:
  anchor_math:
    mode: "FIRST"
    initialize_anchor: "if !focus_set: focus_anchor := x; focus_set := true"
    scale: "scale := max(|focus_anchor|, epsilon_scale)"
    delta_pct: "100 * |x - focus_anchor| / scale"
    bin_index: "floor(delta_pct / bin_width_pct)"
  capacity_clamp:
    rule: "if slot_limit >= 0 and slots.size >= slot_limit: clamp slot_id to min(slot_id, slot_limit-1) and ensure slot exists"
  notes:
    - "EMA/WINDOW modes are reserved for Phase B; fields present for forward-compat."
    - "tick() should not reorder anchor updates relative to weight reinforcement within a single neuron step."

growth_v4:
  classes:
    GrowthPolicy:
      fields:
        enabled: true
        minTicksBetweenGrowth: 50
        layerGrowthThreshold: 0.75
        maxLayers: 32
        newLayerConnectProbability: 0.20
        blueprintExcitatory: 64
        blueprintInhibitory: 16
        blueprintModulatory: 8
        neuronGrowthEnabled: true
        neuronMinTicksBetweenGrowth: 50
        neuronMaxPerLayer: 0
        neuronInheritWiringProb: 0.5
        outlierGrowthThresholdPct: 60.0
    GrowthEngine:
      methods:
        - "static void maybeGrow(Region region, GrowthPolicy policy)"
        - "static void maybeGrowNeurons(Region region, GrowthPolicy policy)"
      semantics:
        - "Best-effort; never throw into Region.tick()."
        - "Layer growth triggers by pressure proxy (avg slots/neuron) beyond threshold, respects cooldown/maxLayers; new layer blueprint E/I/M and connect probability."
        - "Neuron growth optional: if layer offers spawnSiblingLike, engine may call (or use reflection) when (slots at capacity) AND (delta_pct vs anchor ≥ threshold)."
  integration_points:
    region_tick_after_metrics: "[GROWNET:ANCHOR::AFTER_METRICS] optional hook site to call maybeGrow*/decide growth."

ports_and_edges:
  bind_scalar:
    ensure_input_edge: "create a 1-neuron input edge layer per port if missing"
    wire: "edge -> target layers with probability=1.0"
  bind_output_scalar:
    ensure_output_edge: "create a 1-neuron output edge layer per port if missing"
    wire: "target layers -> edge with probability=1.0"
  bind_2d:
    ensure_input_edge_type: "InputLayer2D; replace existing edge if wrong type/shape"
    wire: "edge -> target layers with probability=1.0"
  tick_contracts:
    tick_scalar: "port must have InputEdge; deliver value to the edge layer or mapped entry layers; endTick() all layers; decay bus"
    tick_2d: "port must be bound to InputLayer2D edge; forwardImage(frame) then endTick/decay"
    tick_image: "delegates to tick_2d"

testing_obligations:
  temporal_focus_sequence:
    description: "Feeding 1.0..2.0 in 0.1 steps should create ≥10 slots (FIRST mode, 10% bins)."
  capacity_clamp:
    description: "With slot_limit=4 and monotonically increasing inputs, slot ids must clamp at 3 and not error."
  ports_bindings:
    description: "bindInput()/bindInput2D() create InputEdge and wire to targets; tick should deliver to edge or direct mapping."
  non_throwing_tick:
    description: "tick paths must not throw; failures are reflected in metrics/logs."

migration_from_v3:
  removed:
    - "No separate legacy path for ports; 'ports are edges' is the single model."
  renamed_or_aliased:
    - {from: "tickImage", to: "tick2D (tickImage delegates)", status: "keep alias for at least one minor version"}
  added_fields:
    - "SlotConfig.{anchorMode,binWidthPct,epsilonScale,recenterThresholdPct,recenterLockTicks,anchorBeta,outlierGrowthThresholdPct,slotLimit}"
    - "Neuron.{focusAnchor,focusSet,focusLockUntilTick}"
  behavior_changes:
    - "Slot selection can use anchor-based FIRST mode; capacity clamp enforced by slot_limit where available."

compliance_checklist:
  - "Java surface matches signatures listed above; other languages mirror names/semantics per conventions."
  - "Python public fields/methods are snake_case; no leading underscores for public API fields."
  - "Mojo uses struct/fn and explicit typing; no non-portable tricks."
  - "C++ headers declare the same conceptual shape; implementation mirrors Java semantics."
  - "Region.tick* never throws; growth is best-effort."
  - "Unit tests for temporal focus & capacity clamp exist in src/<lang>/tests/."
